<!DOCTYPE html>
<html>

<head>
  <title>Playoff Tracker 2024</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Latest compiled and minified CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
    crossorigin="anonymous"></script>

  <style>
    .sor-col { background: #fff7a8; }
    .psor-col { background: #add8e6; }
  </style>

  <style>
    /* Mobile-only message hidden on desktop */
    .mobile-note {
      display: none;
      font-style: italic;
      color: #666;
      margin: 0.5rem 0;
    }

    @media (max-width: 768px) {
      .mobile-note { display: block; }

      /* Hide all tables except the Rankings table */
      table { display: none !important; }
      #rankingsTable { display: table !important; width: 100%; }

      /* Hide all columns by default on mobile */
      #rankingsTable th, #rankingsTable td { display: none; }

      /* Show only Rank (1), Team (2), Record (3), SoR Avg (5) */
      #rankingsTable th:nth-child(1), #rankingsTable td:nth-child(1),
      #rankingsTable th:nth-child(2), #rankingsTable td:nth-child(2),
      #rankingsTable th:nth-child(3), #rankingsTable td:nth-child(3),
      #rankingsTable th:nth-child(5), #rankingsTable td:nth-child(5) {
        display: table-cell;
      }
    }
  </style>

  <style>
    .dropdown-menu.seasons-menu,
    #seasonsDropdown + .dropdown-menu {
      max-height: 70vh !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
      overscroll-behavior: contain !important;
      touch-action: pan-y !important;
    }
    .dropdown-menu.seasons-menu .dropdown-item { white-space: nowrap; }

    @media (max-width: 768px) {
      .team-schedule-title { display: none !important; }
    }
    @media (max-width: 768px) {
      #rankingsTable th.col-power-sor,
      #rankingsTable td.col-power-sor { display: table-cell !important;background: #add8e6 }
    }
  </style>
  <style>
    #aboutCollapse, #glossaryCollapse {
      margin-top: 4rem; /* adjust as needed */
    }
  </style>
</head>

<body>
  <header>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top">
      <div class="container-fluid">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarExample01" aria-controls="navbarExample01" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
        <div class="collapse navbar-collapse" id="navbarExample01">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item active">
              <a class="nav-link" aria-current="page" href="/teams?year=<%= new Date().getFullYear() %>">Home</a>
            </li>

            <!-- Seasons Dropdown -->
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle"
              href="#"
              id="seasonsDropdown"
              role="button"
              data-bs-toggle="dropdown"
              data-bs-auto-close="outside"
              data-bs-display="static">
             Seasons
           </a>
              <ul class="dropdown-menu seasons-menu" aria-labelledby="seasonsDropdown">
                <% 
                  const currentYear = new Date().getFullYear();
                  for (let y = currentYear; y >= 1900; y--) { 
                %>
                  <li>
                    <a class="dropdown-item" href="/teams?year=<%= y %>">
                      <%= y %>
                    </a>
                  </li>
                <% } %>
              </ul>
              <!-- Mobile-only extra items (About & Glossary) -->
<ul class="navbar-nav d-lg-none mt-2">
  <li class="nav-item">
    <a class="nav-link js-open-info" href="#" data-info="about">About</a>
  </li>
  <li class="nav-item">
    <a class="nav-link js-open-info" href="#" data-info="glossary">Glossary</a>
  </li>
</ul>



            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!-- Navbar -->
  </header>

  <div class="container-md">
    <div class="row text-center" style="display:flex; flex-wrap: wrap">
      <div class="container" style="margin-top: 80px;">
        <div class="row">

          <%
          // Helper functions
          function recordToString(wins, losses) {
            return `${wins}-${losses}`;
          }

          const powerConferences = ["SEC", "ACC", "Big Ten", "Big 12", "Pac-12"];
          function isPowerConf(conf, team) {
            if (!conf) return false;
            if (powerConferences.includes(conf)) return true;
            if (team === "Notre Dame") return true;
            return false;
          }

          // Build unique list of FBS teams
          let fbsTeamsSet = new Set();
          games.forEach(game => {
            if (game.homeClassification === 'fbs') fbsTeamsSet.add(game.homeTeam);
            if (game.awayClassification === 'fbs') fbsTeamsSet.add(game.awayTeam);
          });
          let fbsTeams = Array.from(fbsTeamsSet).sort();

          // Team stats container
          let teamStats = {};
          let conferenceRecords = {};
          let teamConference = {};   

          fbsTeams.forEach(team => {
            teamStats[team] = {
              wins: 0,
              losses: 0,
              qualityTotal: 0,
              wlqTotal: 0,
              gamesPlayed: 0,
              gameStats: []
            };
          });

          //
          // ---------- PASS 1: build wins/losses and quality totals ----------
          //
          games.forEach(game => {
            if (!game.completed) return; // ✅ Skip incomplete games

            ['home', 'away'].forEach(side => {
              const team = game[side + 'Team'];
              const teamClass = game[side + 'Classification'];
              if (teamClass !== 'fbs') return;

              const oppSide = side === 'home' ? 'away' : 'home';
              const opponent = game[oppSide + 'Team'];
              const opponentClass = game[oppSide + 'Classification'];
              const opponentConf = game[oppSide + 'Conference'];

              const teamPoints = game[side + 'Points'];
              const oppPoints = game[oppSide + 'Points'];
              const won = teamPoints > oppPoints;

               // ✅ Capture team’s conference name if available
      const teamConf = game[side + 'Conference'];
      if (teamConf && !teamConference[team]) {
        teamConference[team] = teamConf;
      }

              const opponentInPower = isPowerConf(opponentConf, opponent);

              let qualityChange = 0;
              if (opponentClass === 'fcs') {
                qualityChange = won ? 0.0 : -2.0;
              } else if (opponentInPower) {
                qualityChange = won ? 1.35 : -0.5;
              } else if (opponentClass === 'fbs') {
                qualityChange = won ? 1.0 : -1.0;
              }

              if (won) teamStats[team].wins++;
              else teamStats[team].losses++;
              teamStats[team].gamesPlayed++;

              teamStats[team].qualityTotal += qualityChange;

              if (game.conferenceGame) {
  if (!conferenceRecords[team]) {
    conferenceRecords[team] = { confWins: 0, confLosses: 0 };
  }
  if (won) {
    conferenceRecords[team].confWins++;
  } else {
    conferenceRecords[team].confLosses++;
  }
}


              // Store game info for later WLQ calculation
              teamStats[team].gameStats.push({
                game,
                won,
                qualityChange,
                opponent,
                opponentClass,
                opponentConf
              });
            });
          });

          //
          // ---------- PASS 2: calculate WLQ scores using cumulative opponent totals ----------
          //
          fbsTeams.forEach(team => {
            const t = teamStats[team];
            if (!t) return;

            t.wlqTotal = 0; // reset; accumulate fresh from per-game results

            t.gameStats.forEach(g => {
              const { game, won, opponent, opponentClass } = g;
              const isChampionship = (game.notes || '').toLowerCase().includes('championship');
              const opponentQuality = (teamStats[opponent] && teamStats[opponent].qualityTotal) || 0;

              // Point differential from `team` perspective
              const teamIsHome = (game.homeTeam === team);
              const pointDiff = teamIsHome
                ? (Number(game.homePoints || 0) - Number(game.awayPoints || 0))
                : (Number(game.awayPoints || 0) - Number(game.homePoints || 0));

              const isTrueAway = (game.awayTeam === team) && (game.neutralSite === false);

              let wlqScore = 0;

              if (opponentClass === 'fcs') {
                // FCS: wins = 0, losses = -1.5 (except championship loss uses current SoR × 0.90)
                if (won) {
                  wlqScore = 0.0;
                } else {
                  wlqScore = isChampionship ? (t.wlqTotal * 0.90) : -2.0;
                }
              } else if (opponentClass === 'fbs') {
                // ---- Win multipliers ----
                // Base: 10%
                // True away win: 23% (≤10 pts), 25% (>10 pts)
                // Home/neutral win by >10: 12%
                // BUT: if opponentQuality < 0, always 10% (override)
                let winMult = 0.10;
                if (won) {
                  if (opponentQuality < 0) {
                    winMult = 0.10; // negative OQS override
                  } else if (isTrueAway) {
                    winMult = (pointDiff > 10) ? 0.25 : 0.23;
                  } else if (pointDiff > 10) {
                    winMult = 0.12;
                  }
                }

                // ---- Loss multipliers ----
                // If opponentQuality ≥ 0 and close loss (pointDiff ≥ -7):
                //   trueAway = 12%, else = 10%
                // Else (loss by >7 OR opponentQuality < 0): 6%
                let lossMult = 0.06;
                if (!won) {
                  if (opponentQuality >= 0 && pointDiff >= -7) {
                    lossMult = isTrueAway ? 0.12 : 0.10;
                  } else {
                    lossMult = 0.06;
                  }
                }

                // ---- Championship overrides ----
                if (isChampionship) {
                  if (won) {
                    wlqScore = 1 + opponentQuality * 0.30;     // championship win
                  } else {
                    wlqScore = 1.0;              
                  }
                } else {
                  wlqScore = won
                    ? (1 + opponentQuality * winMult)
                    : (-1 + opponentQuality * lossMult);
                }
              } else {
                // Fallback if opponentClass is unknown
                wlqScore = won ? 1 : -1;
              }

              t.wlqTotal += wlqScore;
              g.wlqScore = wlqScore; // store for display
            });
          });

          // Rankings Table
          const rankings = fbsTeams.map(team => {
            const s = teamStats[team];
            return {
              teamName: team,
              record: recordToString(s.wins, s.losses),
              wlqTotal: s.wlqTotal,
              wlqAvg: s.gamesPlayed > 0 ? s.wlqTotal / s.gamesPlayed : 0
            };
          }).sort((a, b) => b.wlqAvg - a.wlqAvg);
          %>

<%
  // -------- Additional per-team averages, SoS, bonuses, and resort --------
  // (Timestamp string removed; we'll render the time in the user's local TZ via JS)

  // Per-team season averages based on completed games
  rankings.forEach(r => {
    const s = teamStats[r.teamName];
    let tPts = 0, oPts = 0, cnt = 0;
    (s.gameStats || []).forEach(({game}) => {
      const homeIsTeam = game.homeTeam === r.teamName;
      const teamPoints = homeIsTeam ? Number(game.homePoints || 0) : Number(game.awayPoints || 0);
      const oppPoints  = homeIsTeam ? Number(game.awayPoints || 0) : Number(game.homePoints || 0);
      tPts += teamPoints; oPts += oppPoints; cnt++;
    });
    r.scoringAvg = cnt ? (tPts / cnt) : 0;
    r.giveAvg    = cnt ? (oPts / cnt) : 0;
    r.marginAvg  = r.scoringAvg - r.giveAvg;

    // SoS average: opponents' quality totals to date
    {
      let sosSum = 0, sosCnt = 0;
      (typeof games !== 'undefined' && Array.isArray(games) ? games : (typeof locals !== 'undefined' && locals && Array.isArray(locals.games) ? locals.games : [])).forEach((game) => {
        if (!game || !game.completed) return;
        if (game.homeTeam !== r.teamName && game.awayTeam !== r.teamName) return;
        const opp = (game.homeTeam === r.teamName) ? game.awayTeam : game.homeTeam;
        const oppClass = (game.homeTeam === r.teamName) ? (game.awayClassification || 'fbs') : (game.homeClassification || 'fbs');
        let oppQ;
        if (oppClass === 'fcs' || !teamStats[opp]) {
          oppQ = -2.0;  // FCS or untracked opponent
        } else {
          oppQ = Number(teamStats[opp].qualityTotal) || 0;
        }
        sosSum += oppQ; sosCnt++;
      });
      r.sosAvg = sosCnt ? (sosSum / sosCnt) : 0;
    }
  });

  // Percentile cutoffs
  const asc = (a,b)=>a-b;
  const sArr = rankings.map(r=>r.scoringAvg).slice().sort(asc);
  const gArr = rankings.map(r=>r.giveAvg).slice().sort(asc);
  const mArr = rankings.map(r=>r.marginAvg).slice().sort(asc);
  const n = rankings.length || 1;
  const idxTop = Math.max(0, Math.ceil(0.9*n) - 1);
  const scoringCut = sArr[idxTop];
  const giveCut    = gArr[Math.min(gArr.length-1, Math.floor(0.1*n))];
  const marginCut  = mArr[idxTop];

  rankings.forEach(r => {
    r.isTopScoringAvg = r.scoringAvg >= scoringCut;
    r.isBottomGiveAvg = r.giveAvg <= giveCut;
    r.isTopMarginAvg  = r.marginAvg >= marginCut;
  });

 // Power SoR Avg: (Strength of Record total + bonuses) / gamesPlayed
rankings.forEach(r => {
  const gp = (teamStats[r.teamName] && teamStats[r.teamName].gamesPlayed) ? teamStats[r.teamName].gamesPlayed : 0;
  const giveBonusEligible = (gp > 0) && r.isBottomGiveAvg;   // ← only if they've played
  const bonus = (r.isTopScoringAvg ? 0.2 : 0)
             + (giveBonusEligible ? 0.2 : 0)
             + (r.isTopMarginAvg ? 0.5 : 0);
  r.powerSorAvg = gp > 0 ? (r.wlqTotal + bonus) / gp : 0;
});


  // Resort rankings by Power SoR Avg (desc)
  rankings.sort((a, b) => b.powerSorAvg - a.powerSorAvg);
%>

<h2 id="asOfHeader">Rankings as of ...</h2>
<p class="mobile-note">(For more data, open website on a computer.)</p>

<!-- Buttons row (equal width) -->
<div class="row mt-2 mb-3 d-none d-lg-flex">
  <div class="col-3 pe-lg-1">
    <button class="btn btn-sm btn-outline-secondary w-100" type="button"
            data-bs-toggle="collapse" data-bs-target="#aboutCollapse"
            aria-expanded="false" aria-controls="aboutCollapse">
      About Rankings
    </button>
  </div>
  <div class="col-3 text-end ps-lg-1">
    <button class="btn btn-sm btn-outline-secondary w-100" type="button"
            data-bs-toggle="collapse" data-bs-target="#glossaryCollapse"
            aria-expanded="false" aria-controls="glossaryCollapse">
      Glossary
    </button>
  </div>
</div>

<!-- About Rankings collapsible -->
<div class="collapse" id="aboutCollapse">
  <div class="card card-body text-start">
    <h5>About This Ranking System</h5>
    <p>
      Unlike the <strong>AP Poll</strong> or <strong>Coaches Poll</strong>, which are based on the subjective opinions of sportswriters or coaches,
      this ranking system is <em>data-driven</em> and recalculates team strength after every game using objective metrics.
    </p>
    <p>
      It doesn’t rely on reputation, preseason expectations, or “eye tests.” Instead, it builds a team’s standing from the ground up by tracking:
    </p>
    <ul>
      <li><strong>Quality of Wins and Losses (Quality Score):</strong>
        Beating a strong team counts more than beating a weak one; losing to a weak team counts more heavily against you.
        Wins over Power 5 teams are weighted higher, while FCS losses penalize more.
      </li>
      <li><strong>Strength of Record (SoR):</strong>
        How a team performed relative to the total quality of its opponent(s).
        Winning against strong opponents yields bigger multipliers; losing close games is less damaging; winning by multiple scores enhances your strength.
      </li>
      <li><strong>Contextual Multipliers:</strong>
        True away game wins carry extra credit (23–25%).
        Wins with a bigger scoring margin at home/neutral get a bump (12%).
        Close losses to strong teams are penalized less (10–12%).
      </li>
      <li><strong>Bonus Adjustments:</strong>
        Teams in the top 10% of scoring offense, scoring defense, or margin of victory get small boosts that reflect elite performance.
      </li>
      <li><strong>Power SoR Avg (final metric):</strong>
        The overall strength-of-record total plus bonus adjustments, normalized by games played.
        Teams are ranked by this number, with ties sharing the same rank.
      </li>
    </ul>
    <p>
      <strong>Bottom line:</strong> Whereas AP/Coaches Polls measure <em>perception</em>, this system measures <em>performance + context</em>.
      It answers:
    </p>
    <blockquote>
      <em>“How strong is a team’s season résumé, when you consider who they beat, where they beat them, and how they performed relative to opponent strength?”</em>
    </blockquote>
    <p>
      It’s designed to surface the teams that have <em>earned</em> their ranking on the field, regardless of brand name or preseason hype.
    </p>
    <p><strong>By design, these rankings will look vastly different. Especially early in the season as limited game data has taken place.  Where coaches and associated press polls start out as pure projections, this poll starts with every team in FBS sharing the rank of #1 and adjusts as the results on the field roll in.</strong></p>
  </div>
</div>
<div class="collapse" id="glossaryCollapse">
  <div class="card card-body text-start">
    <dl class="row mb-0">
      <dt class="col-sm-3">Rank</dt>
      <dd class="col-sm-9">Ordering based on <strong>Power SoR Avg</strong> (higher is better), with ties sharing a rank.</dd>

      <dt class="col-sm-3">Team</dt>
      <dd class="col-sm-9">FBS teams detected from the season schedule.</dd>

      <dt class="col-sm-3">Record</dt>
      <dd class="col-sm-9">Wins–Losses through completed games.</dd>

      <dt class="col-sm-3">Quality Score</dt>
      <dd class="col-sm-9">Sum of results versus opponents. +1.35 for P5 win, -0.5 for P5 loss, +1.0 for FBS win, -1.0 for FBS loss, 0.0 for FCS win, -2.0 for FCS loss.</dd>

      <dt class="col-sm-3">Strength of Record</dt>
      <dd class="col-sm-9">
        How a team did versus an opponent's total accumulated quality score.
        <ul>
          <li>Win home/neutral: 1 + (OQS × 10%).</li>
          <li>Win home/neutral by &gt;10: 1 + (OQS × 12%).</li>
          <li>Win on the road by ≤10: 1 + (OQS × 23%).</li>
          <li>Win on the road by &gt;10: 1 + (OQS × 25%).</li>
          <li><strong>Any win vs negative OQS:</strong> 1 + (OQS × 10%).</li>
          <li>Loss vs non-negative OQS by ≤7 (home/neutral): -1 + (OQS × 10%).</li>
          <li>Loss vs non-negative OQS by ≤7 (trueAway): -1 + (OQS × 12%).</li>
          <li>Loss by &gt;7 <em>or</em> vs negative OQS: -1 + (OQS × 6%).</li>
          <li>Championship win: 1 + (OQS × 30%).</li>
          <li>Championship loss: 1.0.</li>
        </ul>
      </dd>

      <dt class="col-sm-3">SoR Avg</dt>
      <dd class="col-sm-9">SoR total divided by games played.</dd>

      <dt class="col-sm-3">PF</dt>
      <dd class="col-sm-9">Average points scored per game. Top 10% earns a bonus in Power SoR Avg.</dd>

      <dt class="col-sm-3">PA</dt>
      <dd class="col-sm-9">Average points allowed per game. Bottom 10% (lowest points allowed) earns a bonus in Power SoR Avg.</dd>

      <dt class="col-sm-3">SM</dt>
      <dd class="col-sm-9">Scoring Avg minus Points Allowed Avg. Top 10% earns a bonus in Power SoR Avg.</dd>

      <dt class="col-sm-3">SoS</dt>
      <dd class="col-sm-9">Average opponent quality to date.</dd>

      <dt class="col-sm-3">Power SoR</dt>
      <dd class="col-sm-9">(<em>SoR total</em> + Bonus for Top 10% Scoring Avg, Bottom 10% Give Avg, Top 10% Margin) ÷ games played.</dd>
    </dl>
  </div>
</div>

<table id="rankingsTable" border="1" cellspacing="0" cellpadding="5">
  <thead>
    <tr>
      <th>Rank</th>
      <th>Team</th>
      <th>W/L</th>
      <th>SoR</th>
      <th class="sor-col">SoR Avg</th>
      <th>PF</th>
      <th>PA</th>
      <th>SM</th>
      <th>SoS</th>
      <th class="col-power-sor psor-col">PSoR</th>
    </tr>
  </thead>
  <tbody>
    <%
      let lastPower = NaN;
      let lastRank = 0;
      rankings.forEach((r, i) => {
        let rank;
        if (!isNaN(lastPower) && r.powerSorAvg.toFixed(3) === lastPower.toFixed(3)) {
          rank = lastRank;
        } else {
          rank = i + 1;
          lastRank = rank;
          lastPower = r.powerSorAvg;
        }
    %>
      <tr>
        <td><%= rank %></td>
        <td><%= r.teamName %></td>
        <td
  data-bs-toggle="tooltip"
  data-bs-placement="top"
  title="<%= (teamConference[r.teamName] || 'Conf') %> Record [<%= (conferenceRecords[r.teamName]?.confWins || 0) %>-<%= (conferenceRecords[r.teamName]?.confLosses || 0) %>]">
  <%= r.record %>
</td>
        <td><%= r.wlqTotal.toFixed(2) %></td>
        <td class="sor-col"><%= r.wlqAvg.toFixed(3) %></td>
        <td><%= r.scoringAvg.toFixed(1) %><% if (r.isTopScoringAvg) { %> (0.2)<% } %></td>
        <td>
  <%= r.giveAvg.toFixed(1) %>
  <% if (r.isBottomGiveAvg && (teamStats[r.teamName] && teamStats[r.teamName].gamesPlayed > 0)) { %>
    (0.2)
  <% } %>
</td>
        <td><%= r.marginAvg.toFixed(1) %><% if (r.isTopMarginAvg) { %> (0.5)<% } %></td>
        <td><%= (typeof r.sosAvg === 'number' ? r.sosAvg : 0).toFixed(2) %></td>
        <td class="col-power-sor psor-col"><%= r.powerSorAvg.toFixed(3) %></td>
      </tr>
    <% }) %>
  </tbody>
</table>

<hr />

<% fbsTeams.forEach(team => { 
    const stats = teamStats[team];
    let wins = 0, losses = 0;
    let runningWlqTotal = 0;
    let runningQualityTotal = 0;

    // scoring totals
    let teamPointsTotal = 0;
    let oppPointsTotal = 0;
    let gamesCount = 0;
%>
  <%
    // SoS tracking for this team
    let runningSoS = 0;
    // Future SoS = sum of opponent quality totals for incomplete games for this team
    let futureSoS = 0;
    (games || []).forEach(gm => {
      const isTeamGame = (gm.homeTeam === team || gm.awayTeam === team);
      if (isTeamGame && !gm.completed) {
        const opponentNameFS = gm.homeTeam === team ? gm.awayTeam : gm.homeTeam;
        const oppStatsFS = teamStats[opponentNameFS];
        futureSoS += oppStatsFS ? oppStatsFS.qualityTotal : 0;
      }
    });
    %>
    <h3 class="team-schedule-title">
  <%= team %> Schedule
  (Record: <%= recordToString(stats.wins, stats.losses) %>)
  <span class="text-muted" style="font-weight: normal;">
    &nbsp;Conf:[
      <%= (conferenceRecords[team]?.confWins || 0) %>-
      <%= (conferenceRecords[team]?.confLosses || 0) %>
    ]
  </span>
</h3>
  <table border="1" cellspacing="0" cellpadding="5">
    <thead>
      <tr>
        <th>Week</th>
        <th>Home</th>
        <th>Away</th>
        <th><%= team %> Score</th>
        <th>Opp Score</th>
        <th>Result</th>
        <th>W/L</th>
        <th>QS</th>
        <th class="sor-col">SoR</th>
        <th>SoS</th>
        <th>PF/PA(SM)</th>
      </tr>
    </thead>
    <tbody>
      <% stats.gameStats.forEach(({game, won, qualityChange, wlqScore}) => {
          if (won) wins++; else losses++;
          const runningRecord = recordToString(wins, losses);
          runningWlqTotal += wlqScore;
          runningQualityTotal += qualityChange;

          const homeIsTeam = game.homeTeam === team;
          const awayIsTeam = game.awayTeam === team;

          const homeOppStats = teamStats[game.homeTeam] || { wins: 0, losses: 0, qualityTotal: 0 };
          const awayOppStats = teamStats[game.awayTeam] || { wins: 0, losses: 0, qualityTotal: 0 };

          // scoring totals
          let teamPoints = homeIsTeam ? game.homePoints : game.awayPoints;
          let oppPoints  = homeIsTeam ? game.awayPoints : game.homePoints;
          teamPointsTotal += teamPoints;
          oppPointsTotal += oppPoints;
          gamesCount++;

          const teamAvg = teamPointsTotal / gamesCount;
          const oppAvg  = oppPointsTotal / gamesCount;
          const margin  = teamAvg - oppAvg;
      %>
        <tr>
          <td><%= game.week %></td>

          <!-- Home Team -->
          <td>
            <% if (homeIsTeam) { %>
              <%= game.homeTeam %>
            <% } else { %>
              <%= game.homeTeam %>
              <% if (game.homeClassification === 'fbs') { %>
                [<%= recordToString(homeOppStats.wins, homeOppStats.losses) %>] 
                (<%= homeOppStats.qualityTotal.toFixed(2) %>)
              <% } else { %> (N/A) <% } %>
            <% } %>
          </td>

          <!-- Away Team -->
          <td>
            <% if (awayIsTeam) { %>
              <%= game.awayTeam %>
            <% } else { %>
              <%= game.awayTeam %>
              <% if (game.awayClassification === 'fbs') { %>
                [<%= recordToString(awayOppStats.wins, awayOppStats.losses) %>] 
                (<%= awayOppStats.qualityTotal.toFixed(2) %>)
              <% } else { %> (N/A) <% } %>
            <% } %>
          </td>

          <td><%= teamPoints %></td>
          <td><%= oppPoints %></td>
          <td><%= won ? "win" : "loss" %></td>
          <td
  data-bs-toggle="tooltip"
  data-bs-placement="top"
  title="<%= (teamConference[team] || 'Conf') %> Record [<%= (conferenceRecords[team]?.confWins || 0) %>-<%= (conferenceRecords[team]?.confLosses || 0) %>]">
  <%= runningRecord %>
</td>

          <td><%= runningQualityTotal.toFixed(2) %> (<%= qualityChange.toFixed(2) %>)</td>
          <td><%= runningWlqTotal.toFixed(2) %> (<%= wlqScore.toFixed(2) %>)</td>
          
        <% 
          const opponentName = homeIsTeam ? game.awayTeam : game.homeTeam;
          const oppQualityNow = (teamStats[opponentName] ? teamStats[opponentName].qualityTotal : 0);
          runningSoS += Number(oppQualityNow) || 0;
        %>
        <td><%= runningSoS.toFixed(2) %></td>
        <td>
          <% if (gamesCount <= 2) { %>
            <%= (teamPointsTotal / gamesCount).toFixed(0) %>-
            <%= (oppPointsTotal / gamesCount).toFixed(0) %>
            (<%= margin.toFixed(0) %>)
          <% } else { %>
            <%= teamAvg.toFixed(1) %>-
            <%= oppAvg.toFixed(1) %>
            (<%= margin.toFixed(1) %>)
          <% } %>
        </td>
        </tr>
      <% }) %>
      <% if (futureSoS > 0) { %>
        <tr>
          <td colspan="9"></td>
          <td>Future SoS (<%= futureSoS.toFixed(2) %>)</td>
          <td></td>
        </tr>
      <% } %>

    </tbody>
  </table>
  <hr />
<% }) %>

        </div>
      </div>
    </div>
  </div>

  <div class="footer d-flex justify-content-center align-items-center">
    <h5>&copy; Taylor Bros. Gaming - 2025</h5>
  </div>

  <style>
    /* rankings table sorting helpers */
    #rankingsTable th { cursor: pointer; user-select: none; position: relative; }
    #rankingsTable th .sort-arrow { font-size: 0.8em; margin-left: .35rem; opacity: .4; }
    #rankingsTable th.active .sort-arrow { opacity: 1; }
  </style>

 
  <script>
document.addEventListener("DOMContentLoaded", () => {
  // === Local time header ===
  try {
    const d = new Date();
    const options = { year:'numeric', month:'2-digit', day:'2-digit', hour:'numeric', minute:'2-digit', hour12:true, timeZoneName:'short' };
    const header = document.getElementById("asOfHeader");
    if (header) header.textContent = "Rankings as of " + d.toLocaleString(undefined, options);
  } catch (e) { console.warn("Time header error:", e); }

  // === Rankings table sorting ===
  try {
    const table = document.getElementById("rankingsTable");
    if (table) {
      const headers = Array.from(table.querySelectorAll("thead th"));
      headers.forEach(th => {
        const span = document.createElement("span");
        span.className = "sort-arrow";
        span.textContent = "⇅";
        th.appendChild(span);
      });

      const numericFromText = (t) => {
        const m = t.replace(/,/g, '').match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : NaN;
      };
      const recordToPct = (t) => {
        const m = t.match(/(\d+)\s*-\s*(\d+)/);
        if (!m) return NaN;
        const w = parseInt(m[1],10), l = parseInt(m[2],10);
        return (w+l)>0 ? w/(w+l) : 0;
      };
      const typeOf = (txt) => {
        const t = txt.trim().toLowerCase();
        if (t === 'rank') return 'int';
        if (t === 'team') return 'text';
        if (t === 'w/l') return 'record';
        return 'num';
      };
      const setArrow = (th, asc) => {
        headers.forEach(h => {
          h.classList.remove('active');
          const s=h.querySelector('.sort-arrow'); 
          if (s) s.textContent='⇅';
        });
        const s = th.querySelector('.sort-arrow');
        if (s) { th.classList.add('active'); s.textContent = asc ? '▲' : '▼'; }
      };

      headers.forEach((th, idx) => {
        th.addEventListener('click', () => {
          const tbody = table.tBodies[0];
          const rows = Array.from(tbody.querySelectorAll('tr'));
          const asc = !(th._asc === true); th._asc = asc;
          const kind = typeOf(th.childNodes[0].textContent || th.textContent);
          rows.sort((A,B) => {
            const aT=(A.cells[idx]?.innerText||'').trim();
            const bT=(B.cells[idx]?.innerText||'').trim();
            let aV,bV;
            if (kind==='int'){ aV=parseInt(aT,10); bV=parseInt(bT,10); }
            else if (kind==='record'){ aV=recordToPct(aT); bV=recordToPct(bT); }
            else if (kind==='num'){ aV=numericFromText(aT); bV=numericFromText(bT); }
            else { aV=aT.toLowerCase(); bV=bT.toLowerCase(); }
            const aNaN = (typeof aV==='number' && isNaN(aV));
            const bNaN = (typeof bV==='number' && isNaN(bV));
            if (aNaN && bNaN) return 0; if (aNaN) return 1; if (bNaN) return -1;
            if (aV < bV) return asc ? -1 : 1;
            if (aV > bV) return asc ? 1 : -1;
            return 0;
          });
          rows.forEach(r => tbody.appendChild(r));
          setArrow(th, asc);
        });
      });
    }
  } catch (e) { console.warn("Sorting init error:", e); }

  // === Header tooltips (Rankings + Team tables) ===
  try {
    const headerLongNames = {
      "Rank": "Ranking",
      "Team": "Team",
      "W/L": "Wins–Losses",
      "SoR": "Strength of Record",
      "SoR Avg": "Strength of Record Average",
      "PF": "Scoring Average",
      "PA": "Points Allowed Average",
      "SM": "Scoring Margin",
      "PF/PA(SM)": "Scoring Avg, Points Allowed Avg, (Scoring Margin)",
      "SoS": "Strength of Schedule",
      "PSoR": "Power Strength of Record",
      "Week": "Week of Season",
      "Home": "Home Team",
      "Away": "Away Team",
      "Score": "Points Scored",
      "Opp Score": "Opponent Points Scored",
      "Result": "Win or Loss",
      "Record": "Overall Record",
      "QS": "Cumulative Quality Score (Change from this game)",
      "SoR": "Strength of Record Total (Change from this game)"
    };
    const allThs = document.querySelectorAll("table thead th");
    allThs.forEach(th => {
      const label = (th.childNodes[0]?.textContent || th.textContent || "").trim();
      const longName = headerLongNames[label];
      if (longName) {
        th.setAttribute("data-bs-toggle", "tooltip");
        th.setAttribute("data-bs-placement", "top");
        th.setAttribute("title", longName);
        th.setAttribute("aria-label", longName);
      }
    });
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => { new bootstrap.Tooltip(el, { container: 'body' }); });
  } catch (e) { console.warn("Tooltip init error:", e); }

  // === Mobile navbar links -> modal open ===
  const navCollapseEl = document.getElementById("navbarExample01"); // collapse container id
  const infoModalEl   = document.getElementById("infoModal");
  const infoTitleEl   = document.getElementById("infoModalTitle");
  const infoBodyEl    = document.getElementById("infoModalBody");

  const getNavCollapse = () => {
    if (!navCollapseEl) return null;
    let inst = bootstrap.Collapse.getInstance(navCollapseEl);
    if (!inst) inst = new bootstrap.Collapse(navCollapseEl, { toggle: false });
    return inst;
  };
  const getModal = () => {
    if (!infoModalEl) return null;
    let inst = bootstrap.Modal.getInstance(infoModalEl);
    if (!inst) inst = new bootstrap.Modal(infoModalEl, { backdrop: true, keyboard: true });
    return inst;
  };

  // Close modal when clicking inside modal content (in addition to backdrop + X)
  if (infoModalEl) {
    infoModalEl.addEventListener('shown.bs.modal', () => {
      const content = document.getElementById('infoModalContent');
      const onClickToClose = (e) => {
        if (content.contains(e.target)) {
          const modal = getModal();
          if (modal) modal.hide();
        }
      };
      content.addEventListener('click', onClickToClose, { once: true });
    });
  }

  function openInfo(which) {
    const isAbout = which === 'about';
    const srcCard = document.querySelector(isAbout ? '#aboutCollapse .card' : '#glossaryCollapse .card');
    if (!srcCard) { console.warn("Source content not found for", which); return; }

    if (infoTitleEl) infoTitleEl.textContent = isAbout ? 'About This Ranking System' : 'Glossary';
    if (infoBodyEl) infoBodyEl.innerHTML = srcCard.innerHTML;

    const modal = getModal();
    if (modal) modal.show();
    else console.warn("Modal instance not available");
  }

  const mobileLinks = document.querySelectorAll('.js-open-info[data-info]');
  mobileLinks.forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const which = link.getAttribute('data-info');
      if (!which) return;

      if (window.innerWidth < 992) { // mobile
        const nav = getNavCollapse();
        if (nav && navCollapseEl && navCollapseEl.classList.contains('show')) {
          const onHidden = () => {
            navCollapseEl.removeEventListener('hidden.bs.collapse', onHidden);
            openInfo(which);
          };
          navCollapseEl.addEventListener('hidden.bs.collapse', onHidden);
          nav.hide();
        } else {
          openInfo(which);
        }
      } else {
        // Desktop: toggle in-page collapsibles
        const targetId = which === 'about' ? '#aboutCollapse' : '#glossaryCollapse';
        const target = document.querySelector(targetId);
        if (target) {
          let inst = bootstrap.Collapse.getInstance(target);
          if (!inst) inst = new bootstrap.Collapse(target, { toggle: false });
          inst.toggle();
          const navH = (document.querySelector('.navbar.fixed-top')?.offsetHeight || 0) + 8;
          const top = target.getBoundingClientRect().top + window.pageYOffset - navH;
          window.scrollTo({ top, behavior: 'smooth' });
        }
      }
    });
  });
});
</script>


<!-- Generic Info Modal -->
<div class="modal fade" id="infoModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content" id="infoModalContent">
      <div class="modal-header">
        <h5 class="modal-title" id="infoModalTitle">Info</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="infoModalBody">
        <!-- injected dynamically -->
      </div>
    </div>
  </div>
</div>



</body>
</html>
