<!DOCTYPE html>
<html>

<head>
  <title>Playoff Tracker 2025</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Latest compiled and minified CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
    crossorigin="anonymous"></script>

  <style>
    .sor-col { background: #fff7a8; }
    .psor-col { background: #add8e6; }
  </style>
  <style>
    .team-logo {
      height: 20px;
      width: auto;
      vertical-align: middle;
      margin-right: 6px;
    }
    .team-logo--header {
      height: 28px;
      width: auto;
      vertical-align: middle;
      margin-right: 8px;
    }
  </style>
  

  <style>
    /* Mobile-only message hidden on desktop */
    .mobile-note {
      display: none;
      font-style: italic;
      color: #666;
      margin: 0.5rem 0;
    }

    @media (max-width: 768px) {
      .mobile-note { display: block; }

      /* Hide all tables except the Rankings table */
      table { display: none !important; }
      #rankingsTable { display: table !important; width: 100%; }

      /* Hide all columns by default on mobile */
      #rankingsTable th, #rankingsTable td { display: none; }

      /* Show only Rank (1), Team (2), Record (3), SoR Avg (5) */
      #rankingsTable th:nth-child(1), #rankingsTable td:nth-child(1),
      #rankingsTable th:nth-child(2), #rankingsTable td:nth-child(2),
      #rankingsTable th:nth-child(3), #rankingsTable td:nth-child(3),
      #rankingsTable th:nth-child(5), #rankingsTable td:nth-child(5) {
        display: table-cell;
      }
    }
  </style>

  <style>
    .dropdown-menu.seasons-menu,
    #seasonsDropdown + .dropdown-menu {
      max-height: 70vh !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
      overscroll-behavior: contain !important;
      touch-action: pan-y !important;
    }
    .dropdown-menu.seasons-menu .dropdown-item { white-space: nowrap; }

    @media (max-width: 768px) {
      .team-schedule-title { display: none !important; }
    }
    @media (max-width: 768px) {
      #rankingsTable th.col-power-sor,
      #rankingsTable td.col-power-sor { display: table-cell !important;background: #add8e6 }
    }
  </style>
  <style>
    #aboutCollapse, #glossaryCollapse {
      margin-top: 4rem; /* adjust as needed */
    }
  </style>
</head>

<body>
  <header>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top">
      <div class="container-fluid">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarExample01" aria-controls="navbarExample01" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
        <div class="collapse navbar-collapse" id="navbarExample01">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item active">
              <a class="nav-link" aria-current="page" href="/teams?year=<%= new Date().getFullYear() %>">Home</a>
            </li>

            <!-- Seasons Dropdown -->
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle"
              href="#"
              id="seasonsDropdown"
              role="button"
              data-bs-toggle="dropdown"
              data-bs-auto-close="outside"
              data-bs-display="static">
             Seasons
           </a>
              <ul class="dropdown-menu seasons-menu" aria-labelledby="seasonsDropdown">
                <% 
                  const currentYear = new Date().getFullYear();
                  for (let y = currentYear; y >= 1900; y--) { 
                %>
                  <li>
                    <a class="dropdown-item" href="/teams?year=<%= y %>">
                      <%= y %>
                    </a>
                  </li>
                <% } %>
                
              </ul>
            </li>
              <!-- Mobile-only extra items (About & Glossary) -->
<ul class="navbar-nav d-lg-none mt-2">
  <li class="nav-item">
    <a class="nav-link js-open-info" href="#" data-info="about">About</a>
  </li>
  <li class="nav-item">
    <a class="nav-link js-open-info" href="#" data-info="glossary">Glossary</a>
  </li>
</ul>



            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!-- Navbar -->
  </header>

  <div class="container-md">
    <div class="row text-center" style="display:flex; flex-wrap: wrap">
      <div class="container" style="margin-top: 80px;">
        <div class="row">
          

          <%
          // Helper functions
          function recordToString(wins, losses) {
            return `${wins}-${losses}`;
          }

          const powerConferences = ["SEC", "ACC", "Big Ten", "Big 12", "Pac-12"];
          function isPowerConf(conf, team) {
            if (!conf) return false;
            if (powerConferences.includes(conf)) return true;
            if (team === "Notre Dame") return true;
            return false;
          }

          // Build unique list of FBS teams
          let fbsTeamsSet = new Set();
          games.forEach(game => {
            if (game.homeClassification === 'fbs') fbsTeamsSet.add(game.homeTeam);
            if (game.awayClassification === 'fbs') fbsTeamsSet.add(game.awayTeam);
          });
          let fbsTeams = Array.from(fbsTeamsSet).sort();

          // Team stats container
          let teamStats = {};
          let conferenceRecords = {};
          let teamConference = {};   

          fbsTeams.forEach(team => {
            teamStats[team] = {
              wins: 0,
              losses: 0,
              qualityTotal: 0,
              wlqTotal: 0,
              gamesPlayed: 0,
              gameStats: [],
              hasChampionship: false,
              wonChampionship: false,
              lostChampionship: false
            };
          });

          //
          // ---------- PASS 1: build wins/losses and quality totals ----------
          //
          games.forEach(game => {
            if (!game.completed) return; // still skip incomplete

            ['home', 'away'].forEach(side => {
              const team = game[side + 'Team'];
              const teamClass = game[side + 'Classification'];
              if (teamClass !== 'fbs') return;

              const oppSide = side === 'home' ? 'away' : 'home';
              const opponent = game[oppSide + 'Team'];
              const opponentClass = game[oppSide + 'Classification'];
              const opponentConf = game[oppSide + 'Conference'];

              const teamPoints = Number(game[side + 'Points'] || 0);
              const oppPoints  = Number(game[oppSide + 'Points'] || 0);
              const won = teamPoints > oppPoints;

              // capture team’s conference name if available
              const teamConf = game[side + 'Conference'];
              if (teamConf && !teamConference[team]) teamConference[team] = teamConf;

              const isChampionship = String(game.notes || game.gameName || '').toLowerCase().includes('championship');

              // For table display we include championship games, but we DO NOT add them to QS/SoR totals
              if (isChampionship) {
                teamStats[team].gameStats.push({
                  game,
                  won,
                  qualityChange: 0, // excluded from QS
                  opponent,
                  opponentClass,
                  opponentConf,
                  isChampionship: true
                });
                teamStats[team].hasChampionship = true;
                if (won) teamStats[team].wonChampionship = true;
                else teamStats[team].lostChampionship = true;
                // Do NOT increment wins/losses/gamesPlayed/qualityTotal here
                return;
              }

              const opponentInPower = isPowerConf(opponentConf, opponent);

              let qualityChange = 0;
              if (opponentClass === 'fcs') {
                qualityChange = won ? 0.25 : -2.25;
              } else if (opponentInPower) {
                // QS override per your rules
                const homeIsTeam = (game[side + 'Team'] === game.homeTeam);
                const trueAway   = (game.awayTeam === game[side + 'Team']) && (game.neutralSite === false);
                const margin     = homeIsTeam ? (teamPoints - oppPoints) : (teamPoints - oppPoints);
                const bigWin     = margin > 13;
                const oppName    = opponent;
                const oppNegQS   = (teamStats[oppName] && teamStats[oppName].qualityTotal < 0);

                if (won) {
                  if (oppNegQS) qualityChange = 1.20;
                  else if (trueAway && bigWin) qualityChange = 22.05;
                  else if (!trueAway && bigWin) qualityChange = 1.85;
                  else if (trueAway && !bigWin) qualityChange = 1.70;
                  else qualityChange = 1.50;
                } else {
                  const closeLoss = (margin < 0) && ((-margin) < 8);
                  if (oppNegQS) qualityChange = -1.10;
                  else if (trueAway && closeLoss) qualityChange = -0.20;
                  else if (!trueAway && closeLoss) qualityChange = -0.40;
                  else if (trueAway && !closeLoss) qualityChange = -0.70;
                  else qualityChange = -0.85;
                }
              } else if (opponentClass === 'fbs') {
                // Non-power FBS
                const homeIsTeam = (game[side + 'Team'] === game.homeTeam);
                const trueAway   = (game.awayTeam === game[side + 'Team']) && (game.neutralSite === false);
                const margin     = homeIsTeam ? (teamPoints - oppPoints) : (teamPoints - oppPoints);
                const bigWin     = margin > 13;
                const oppName    = opponent;
                const oppNegQS   = (teamStats[oppName] && teamStats[oppName].qualityTotal < 0);

                if (won) {
                  if (oppNegQS) qualityChange = 1.00;
                  else if (trueAway && bigWin) qualityChange = 1.60;
                  else if (!trueAway && bigWin) qualityChange = 1.40;
                  else if (trueAway && !bigWin) qualityChange = 1.25;
                  else qualityChange = 1.10;
                } else {
                  const closeLoss = (margin < 0) && ((-margin) < 8);
                  if (oppNegQS) qualityChange = -1.30;
                  else if (trueAway && closeLoss) qualityChange = -0.35;
                  else if (!trueAway && closeLoss) qualityChange = -0.55;
                  else if (trueAway && !closeLoss) qualityChange = -0.85;
                  else qualityChange = -1.15;
                }
              }

              if (won) teamStats[team].wins++;
              else teamStats[team].losses++;
              teamStats[team].gamesPlayed++;

              teamStats[team].qualityTotal += qualityChange;

              if (game.conferenceGame) {
                if (!conferenceRecords[team]) {
                  conferenceRecords[team] = { confWins: 0, confLosses: 0 };
                }
                if (won) conferenceRecords[team].confWins++;
                else conferenceRecords[team].confLosses++;
              }

              // Store game info for later WLQ calculation
              teamStats[team].gameStats.push({
                game,
                won,
                qualityChange,
                opponent,
                opponentClass,
                opponentConf,
                isChampionship: false
              });
            });
          });

          //
          // ---------- PASS 2: calculate WLQ scores using cumulative opponent totals ----------
          // === SoR Tier Percentile Helpers (descending: 0 = best QS) ===
          (function(){
            if (typeof __sorTierHelpersInserted === 'undefined') {
              var __sorTierHelpersInserted = true;
              var __fbsTeams = (Array.isArray(fbsTeams) && fbsTeams.length) ? fbsTeams : Object.keys(teamStats || {});
              var __allQS_forTiers = __fbsTeams.map(function(t){ return Number((teamStats[t] && teamStats[t].qualityTotal) || 0); });
              var __sortedQSdesc_forTiers = __allQS_forTiers.slice().sort(function(a,b){ return b - a; });
              function __percentileRankDesc_forTiers(x){
                var n = __sortedQSdesc_forTiers.length;
                if (n <= 1) return 1;
                var greater = 0;
                for (var i=0;i<n;i++){
                  if (__sortedQSdesc_forTiers[i] > x) greater++;
                  else break;
                }
                var p = greater / (n - 1);
                if (p < 0) p = 0;
                if (p > 1) p = 1;
                return p;
              }
              // expose globally for template scope
              globalThis.__percentileRankDesc_forTiers = __percentileRankDesc_forTiers;
            }
          })();

          //
          fbsTeams.forEach(team => {
            const t = teamStats[team];
            if (!t) return;

            t.wlqTotal = 0; // reset; accumulate fresh from per-game results

            t.gameStats.forEach(g => {
              const { game, won, opponent, opponentClass, isChampionship } = g;

              // Skip championship from SoR (wlq) calculations
              if (isChampionship) { g.wlqScore = 0; return; }

              // Point differential from `team` perspective
              const teamIsHome = (game.homeTeam === team);
              const pointDiff = teamIsHome
                ? (Number(game.homePoints || 0) - Number(game.awayPoints || 0))
                : (Number(game.awayPoints || 0) - Number(game.homePoints || 0));

              const isTrueAway = (game.awayTeam === team) && (game.neutralSite === false);

              let wlqScore = 0;

              // === New SoR: Tiered by opponent QS percentile (straight scores, no multipliers) ===
              var __homeIsTeam = (game.homeTeam === team);
              var __pointDiff = __homeIsTeam
                ? (Number(game.homePoints || 0) - Number(game.awayPoints || 0))
                : (Number(game.awayPoints || 0) - Number(game.homePoints || 0));

              var __isTrueAway = (game.awayTeam === team) && (game.neutralSite === false);
              var __bigWin     = (__pointDiff > 13);
              var __closeLoss  = (__pointDiff < 0) && ((-__pointDiff) < 8);

              var __oppClass = String(opponentClass || '').toLowerCase();
              var __oppQS = Number(((teamStats[opponent] && teamStats[opponent].qualityTotal) || 0));
              var __pRank = (typeof __percentileRankDesc_forTiers === 'function') ? __percentileRankDesc_forTiers(__oppQS) : 1;

              function __winBase(p){
                if (p <= 0.10) return 2.35;
                if (p <= 0.35) return 2.0;
                if (p <= 0.55) return 1.55;
                if (p <= 0.75) return 1.15;
                return 1.0; // bottom 10%
              }
              function __lossBase(p){
                if (p <= 0.10) return -0.7;
                if (p <= 0.35) return -0.85;
                if (p <= 0.55) return -1.05;
                if (p <= 0.75) return -1.3;
                return -1.6; // bottom 10%
              }

              if (__oppClass === 'fcs') {
                wlqScore = won ? 0.25 : -2.25;
              } else { // fbs
                var __base = won ? __winBase(__pRank) : __lossBase(__pRank);
                var __isBottom10 = (__pRank > 0.90);
                var __bonus = 0;
                if (!__isBottom10) {
                  if (won) {
                    if (__isTrueAway) __bonus += 0.1;
                    if (__bigWin)     __bonus += 0.1;
                    if (__isTrueAway && __bigWin) __bonus += 0.1;
                  } else {
                    if (__isTrueAway) __bonus += 0.1;
                    if (__closeLoss)  __bonus += 0.1;
                    if (__isTrueAway && __closeLoss) __bonus += 0.1;
                  }
                }
                wlqScore = __base + __bonus;
              }

              t.wlqTotal += wlqScore;
              g.wlqScore = wlqScore; // store for display
            });
          });

          
  // Rankings Table
  // Determine latest completed week across all games
  let latestCompletedWeek = 0;
  (games || []).forEach(gm => {
    if (gm && gm.completed) {
      const w = Number(gm.week || 0);
      if (w > latestCompletedWeek) latestCompletedWeek = w;
    }
  });
  const weekFrac = Math.min(Math.max(latestCompletedWeek, 0), 12) / 12;

  const rankings = fbsTeams.map(team => {
    const s = teamStats[team];

    const gstats = (s.gameStats || []);
    const denom = (s.gamesPlayed || 0); // champs excluded already

    // If denom becomes 0 (e.g., only an FCS win so far), show wlqTotal (no divide) to avoid NaN
    const wlqAvgAdjusted = denom > 0 ? (s.wlqTotal / denom) : s.wlqTotal;

    const __dispW = s.wins + (s.wonChampionship?1:0);
    const __dispL = s.losses + (s.lostChampionship?1:0);
    return {
      teamName: team,
      record: recordToString(__dispW, __dispL),
      wlqTotal: s.wlqTotal,
      wlqAvg: wlqAvgAdjusted,
      sorDenomDebug: denom,
      hasChampionship: !!s.hasChampionship,
      wonChampionship: !!s.wonChampionship,
      lostChampionship: !!s.lostChampionship
    };
  }).sort((a, b) => b.wlqAvg - a.wlqAvg);
%>


<%
  // -------- Additional per-team averages, SoS, bonuses, and resort --------

  // Per-team season averages based on completed (non-champ) games for PF/PA/SM
  rankings.forEach(r => {
    const s = teamStats[r.teamName];
    let tPts = 0, oPts = 0, cnt = 0;
    (s.gameStats || []).forEach(({game, isChampionship}) => {
      if (!game || isChampionship) return; // exclude champ from PF/PA/SM too
      const homeIsTeam = game.homeTeam === r.teamName;
      const teamPoints = homeIsTeam ? Number(game.homePoints || 0) : Number(game.awayPoints || 0);
      const oppPoints  = homeIsTeam ? Number(game.awayPoints || 0) : Number(game.homePoints || 0);
      tPts += teamPoints; oPts += oppPoints; cnt++;
    });
    r.scoringAvg = cnt ? (tPts / cnt) : 0;
    r.giveAvg    = cnt ? (oPts / cnt) : 0;
    r.marginAvg  = r.scoringAvg - r.giveAvg;

    // SoS average: opponents' quality totals to date (all completed incl champ display, but opp QS excludes champ inherently)
    {
      let sosSum = 0, sosCnt = 0;
      (typeof games !== 'undefined' && Array.isArray(games) ? games : (typeof locals !== 'undefined' && locals && Array.isArray(locals.games) ? locals.games : [])).forEach((game) => {
        if (!game || !game.completed) return;
        if (game.homeTeam !== r.teamName && game.awayTeam !== r.teamName) return;
        const opp = (game.homeTeam === r.teamName) ? game.awayTeam : game.homeTeam;
        const oppClass = (game.homeTeam === r.teamName) ? (game.awayClassification || 'fbs') : (game.homeClassification || 'fbs');
        let oppQ;
        if (oppClass === 'fcs' || !teamStats[opp]) {
          oppQ = -2.25;  // FCS or untracked opponent
        } else {
          oppQ = Number(teamStats[opp].qualityTotal) || 0;
        }
        sosSum += oppQ; sosCnt++;
      });
      r.sosAvg = sosCnt ? (sosSum / sosCnt) : 0;
    }
  });

  // Percentile cutoffs
  const asc = (a,b)=>a-b;
  const sArr = rankings.map(r=>r.scoringAvg).slice().sort(asc);
  const gArr = rankings.map(r=>r.giveAvg).slice().sort(asc);
  const mArr = rankings.map(r=>r.marginAvg).slice().sort(asc);
  const n = rankings.length || 1;
  const idxTop = Math.max(0, Math.ceil(0.9*n) - 1);
  const scoringCut = sArr[idxTop];
  const giveCut    = gArr[Math.min(gArr.length-1, Math.floor(0.1*n))];
  const marginCut  = mArr[idxTop];

  rankings.forEach(r => {
    r.isTopScoringAvg = r.scoringAvg >= scoringCut;
    r.isBottomGiveAvg = r.giveAvg <= giveCut;
    r.isTopMarginAvg  = r.marginAvg >= marginCut;
  });

 // Power SoR Avg: bonuses + CHAMPIONSHIP bonus applied PRE-AVERAGE
rankings.forEach(r => {
  const s = teamStats[r.teamName] || { gamesPlayed: 0, gameStats: [] };
  const denomWeighted = (s.gamesPlayed || 0); // champs excluded

  const gp = s.gamesPlayed || 0;
  const giveBonusEligible = (gp > 0) && r.isBottomGiveAvg; // unchanged eligibility rule

  // Base bonuses, scaled by weekFrac (capped at 12/12)
  const pfBase = 0.3, paBase = 0.3, smBase = 0.8;
  const pfAmt = r.isTopScoringAvg ? (pfBase * weekFrac) : 0;
  const paAmt = giveBonusEligible ? (paBase * weekFrac) : 0;
  const smAmt = r.isTopMarginAvg ? (smBase * weekFrac) : 0;
  const bonus = pfAmt + paAmt + smAmt;

  // Championship pre-avg bonus (display champ in record via asterisk only for winners)
  let champBonus = 0;
  if (s.wonChampionship) champBonus = 0.30;
  else if (s.lostChampionship) champBonus = -0.10;

  r.appliedPfBonus = pfAmt;
  r.appliedPaBonus = paAmt;
  r.appliedSmBonus = smAmt;
  r.appliedChampBonus = champBonus;

  const totalPreAvg = r.wlqTotal + bonus + champBonus;
  r.pSorDenomDebug = denomWeighted;
  r.powerSorAvg = denomWeighted > 0 ? (totalPreAvg / denomWeighted) : totalPreAvg;
});
  rankings.sort((a, b) => b.powerSorAvg - a.powerSorAvg);
%>

<h2 id="asOfHeader">Rankings as of ...</h2>
<p class="mobile-note">(For more data, open website on a computer.)</p>
<p class="text-muted small mb-2">* denotes a conference championship winner</p>



<!-- Buttons row (equal width) -->
<div class="row mt-2 mb-3 d-none d-lg-flex">
  <div class="col-3 pe-lg-1">
    <button class="btn btn-sm btn-outline-secondary w-100" type="button"
            data-bs-toggle="collapse" data-bs-target="#aboutCollapse"
            aria-expanded="false" aria-controls="aboutCollapse">
      About Rankings
    </button>
  </div>
  <div class="col-3 text-end ps-lg-1">
    <button class="btn btn-sm btn-outline-secondary w-100" type="button"
            data-bs-toggle="collapse" data-bs-target="#glossaryCollapse"
            aria-expanded="false" aria-controls="glossaryCollapse">
      Glossary
    </button>
  </div>
</div>

<!-- About Rankings collapsible -->
<div class="collapse" id="aboutCollapse">
  <div class="card card-body text-start">
    <h5>About This Ranking System</h5>
    <p>
      Unlike the <strong>AP Poll</strong> or <strong>Coaches Poll</strong>, which are based on the subjective opinions of sportswriters or coaches,
      this ranking system is <em>data-driven</em> and recalculates team strength after every game using objective metrics.
    </p>
    <p>
      It doesn’t rely on reputation, preseason expectations, or the name on the jersey. Instead, it builds a team’s standing from the ground up by tracking:
    </p>
    <ul>
      <li><strong>Quality of Wins and Losses (Quality Score):</strong>
        Beating a strong team counts more than beating a weak one; losing to a weak team counts more heavily against you.
        Wins over Power 5 teams are weighted higher, while FCS losses penalize more.
      </li>
      <li><strong>Strength of Record (SoR):</strong>
        How a team performed relative to the total quality of its opponent(s).
        Winning against strong opponents yields bigger values; close losses are less damaging; true-away and big-margin wins give extra credit.
      </li>
      <li><strong>Contextual Bonuses:</strong>
        True away wins and big-margin wins add small fixed bonuses in SoR tiers (except bottom 10% opponents).
      </li>
      <li><strong>Power SoR Avg (final metric):</strong>
        The overall strength-of-record total plus bonus adjustments (PF/PA/SM), <em>and any championship bonus</em>, normalized by games played.
      </li>
    </ul>
    <p><strong>By design, these rankings will look vastly different.</strong> Early in the season, limited game data can shift ratings rapidly. This model starts with every team tied for #1 and lets on-field results separate them over time.</p>
  </div>
</div>
<div class="collapse" id="glossaryCollapse">
  <div class="card card-body text-start">
    <dl class="row mb-0">
      <dt class="col-sm-3">Rank</dt>
      <dd class="col-sm-9">Ordering based on <strong>PSoR Avg</strong> (higher is better), with ties sharing a rank.</dd>

      <dt class="col-sm-3">Team</dt>
      <dd class="col-sm-9">FBS teams detected from the season schedule.</dd>

      <dt class="col-sm-3">Record</dt>
      <dd class="col-sm-9">Wins–Losses through completed games. <em>* denotes a conference championship winner</em>. Championship games are shown in team tables but excluded from QS and SoR totals.</dd>

      <dt class="col-sm-3">Quality Score (QS)</dt>
      <dd class="col-sm-9">
        Cumulative score from each game, based on opponent type, location, and margin:
        <ul>
          <li><strong>Power FBS (P5):</strong>
            <ul>
              <li>Win away by &gt;13 → 2.05</li>
              <li>Win home by &gt;13 → 1.85</li>
              <li>Win away by ≤13 → 1.70</li>
              <li>Win home by ≤13 → 1.50</li>
              <li>Win vs opponent with negative QS → 1.20</li>
              <li>Loss away by &lt;8 → -0.20</li>
              <li>Loss home by &lt;8 → -0.40</li>
              <li>Loss away by ≥8 → -0.70</li>
              <li>Loss home by ≥8 → -0.85</li>
              <li>Loss vs opponent with negative QS → -1.10</li>
            </ul>
          </li>
          <li><strong>Non-Power FBS (G5):</strong>
            <ul>
              <li>Win away by &gt;13 → 1.60</li>
              <li>Win home by &gt;13 → 1.40</li>
              <li>Win away by ≤13 → 1.25</li>
              <li>Win home by ≤13 → 1.10</li>
              <li>Win vs opponent with negative QS → 1.00</li>
              <li>Loss away by &lt;8 → -0.35</li>
              <li>Loss home by &lt;8 → -0.55</li>
              <li>Loss away by ≥8 → -0.85</li>
              <li>Loss home by ≥8 → -1.15</li>
              <li>Loss vs opponent with negative QS → -1.30</li>
            </ul>
          </li>
          <li><strong>FCS Opponents:</strong> Win = 0.25; Loss = -2.25</li>
        </ul>
      </dd>

      <dt class="col-sm-3">Strength of Record (SoR)</dt>
      <dd class="col-sm-9">
        Per-game scores tiered by opponent <em>QS percentile</em> (descending; 0 = best QS):
        <ul>
          <li>FCS win = 0.25; FCS loss = -2.25</li>
          <li>Top 10% opponent: Win = 2.35, Loss = -0.7</li>
          <li>10.1–35%: Win = 2.0, Loss = -0.85</li>
          <li>35.1–55%: Win = 1.55, Loss = -1.05</li>
          <li>55.1–75%: Win = 1.15, Loss = -1.3</li>
          <li>Bottom 25%: Win = 1.0, Loss = -1.6</li>
        </ul>
        <strong>Bonuses (not applied to bottom-10% tier):</strong>
        <ul>
          <li>Wins: +0.1 true away, +0.1 win by &gt;13, +0.1 extra if both (max +0.3)</li>
          <li>Losses: +0.1 true away, +0.1 loss by &lt;8, +0.1 extra if both (max +0.3)</li>
        </ul>
        <em>Championship games are excluded from SoR.</em>
      </dd>

      <dt class="col-sm-3">SoR Avg</dt>
      <dd class="col-sm-9">SoR total ÷ <em>all games played to date</em> (championship games excluded from SoR total by rule).</dd>

      <dt class="col-sm-3">PF</dt>
      <dd class="col-sm-9">Average points scored per game. Top 10% earns a +0.3 bonus in PSoR Avg, scaled by current week/12.</dd>

      <dt class="col-sm-3">PA</dt>
      <dd class="col-sm-9">Average points allowed per game. Bottom 10% (best defenses) earn a +0.3 bonus, scaled by current week/12.</dd>

      <dt class="col-sm-3">SM</dt>
      <dd class="col-sm-9">Scoring Margin (PF − PA). Top 10% earns a +0.8 bonus, scaled by current week/12.</dd>

      <dt class="col-sm-3">SoS</dt>
      <dd class="col-sm-9">Average opponent cumulative QS to date.</dd>

      <dt class="col-sm-3">Power SoR (PSoR)</dt>
      <dd class="col-sm-9">(SoR total + PF/PA/SM bonuses + <strong>Championship Bonus</strong>) ÷ <em>games played</em>. Championship Bonus: <strong>+0.30</strong> for a championship win, <strong>-0.10</strong> for a championship loss. Applied <em>before</em> averaging.</dd>
    </dl>
  </div>
</div>

<table id="rankingsTable" border="1" cellspacing="0" cellpadding="5">
  <thead>
    <tr>
      <th>Rank</th>
      <th>Team</th>
      <th>W/L</th>
      <th>QS</th>
      <th>SoR</th>
      <th class="sor-col">SoR Avg</th>
      <th>PF</th>
      <th>PA</th>
      <th>SM</th>
      <th>SoS</th>
      <th class="col-power-sor psor-col">PSoR</th>
    </tr>
  </thead>
  <tbody>
    <%
      let lastPower = NaN;
      let lastRank = 0;
      rankings.forEach((r, i) => {
        let rank;
        if (!isNaN(lastPower) && r.powerSorAvg.toFixed(4) === lastPower.toFixed(4)) {
          rank = lastRank;
        } else {
          rank = i + 1;
          lastRank = rank;
          lastPower = r.powerSorAvg;
        }
    %>
      <tr>
        <td><%= rank %></td>
        <td>
  <% if (teamLogos && teamLogos[r.teamName]) { %>
    <img class="team-logo" src="<%= teamLogos[r.teamName] %>" alt="<%= r.teamName %> logo" />
  <% } %>
  <a class="text-decoration-none js-team-link"
     href="#team-<%= r.teamName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') %>">
     <%= r.teamName %>
  </a>
</td>
        <td
  data-bs-toggle="tooltip"
  data-bs-placement="top"
  title="<%= (teamConference[r.teamName] || 'Conf') %> Record [<%= (conferenceRecords[r.teamName]?.confWins || 0) %>-<%= (conferenceRecords[r.teamName]?.confLosses || 0) %>]">
  <%= r.record %><%= r.wonChampionship ? '*' : '' %>
</td>
        <td><%= (teamStats[r.teamName] && teamStats[r.teamName].qualityTotal ? teamStats[r.teamName].qualityTotal : 0).toFixed(2) %></td>
        <td><%= r.wlqTotal.toFixed(2) %></td>
        <td class="sor-col">
  <button type="button" class="btn btn-link p-0 js-open-calc" data-kind="sor" data-team="<%= r.teamName %>"><%= r.wlqAvg.toFixed(3) %>
  </button>
</td>
        <td><%= r.scoringAvg.toFixed(1) %><% if (r.isTopScoringAvg) { %> (0.3)<% } %></td>
        <td>
  <%= r.giveAvg.toFixed(1) %>
  <% if (r.isBottomGiveAvg && (teamStats[r.teamName] && teamStats[r.teamName].gamesPlayed > 0)) { %>
    (0.3)
  <% } %>
</td>
        <td><%= r.marginAvg.toFixed(1) %><% if (r.isTopMarginAvg) { %> (0.8)<% } %></td>
        <td><%= (typeof r.sosAvg === 'number' ? r.sosAvg : 0).toFixed(2) %></td>
        <td class="col-power-sor psor-col">
  <button type="button" class="btn btn-link p-0 js-open-calc" data-kind="psor" data-team="<%= r.teamName %>"><%= r.powerSorAvg.toFixed(4) %>
  </button>
</td>
      </tr>
    <% }) %>
  </tbody>
</table>

<%
  const __calcData = {};
  (fbsTeams || []).forEach(team => {
    const s = teamStats[team] || { gameStats: [] };
    __calcData[team] = { games: [], wlqTotal: Number(s.wlqTotal || 0) };
    (s.gameStats || []).forEach(gs => {
      const gm = gs.game;
      if (!gm || !gm.completed) return;
      const homeIsTeam = (gm.homeTeam === team);
      const opponent = homeIsTeam ? gm.awayTeam : gm.homeTeam;
      const oppStat = teamStats[opponent] || {};
      const oppQ = Number(oppStat.qualityTotal || 0);
      const entry = {
        week: Number(gm.week || 0),
        opponent,
        opponentQS: oppQ,
        wlq: Number(gs.wlqScore || 0),
        result: gs.won ? "W" : "L"
      };
      
// Compute modal tooltip reason for SoR (same tiers/wording as table)
(function(){
  const homeIsTeam2 = (gm.homeTeam === team);
  const trueAway2   = (gm.awayTeam === team) && (gm.neutralSite === false);
  const teamPts2    = homeIsTeam2 ? Number(gm.homePoints || 0) : Number(gm.awayPoints || 0);
  const oppPts2     = homeIsTeam2 ? Number(gm.awayPoints || 0) : Number(gm.homePoints || 0);
  const margin2     = teamPts2 - oppPts2;
  const bigWin2     = (margin2 > 13);
  const closeLoss2  = (margin2 < 0) && ((-margin2) < 8);
  const oppClass2   = homeIsTeam2 ? (gm.awayClassification || 'fbs') : (gm.homeClassification || 'fbs');
  let reason2 = '';
  if (String(oppClass2).toLowerCase() === 'fcs') {
    reason2 = (gs.won ? 'Win vs FCS' : 'Loss vs FCS');
  } else {
    let p2 = (typeof __percentileRankDesc_forTiers === 'function') ? __percentileRankDesc_forTiers(oppQ) : 1;
    let tier2 = 'Bottom 25% opponent';
    if      (p2 <= 0.10) tier2 = 'Top 10% opponent';
    else if (p2 <= 0.35) tier2 = 'Top 35% opponent';
    else if (p2 <= 0.55) tier2 = 'Top 55% opponent';
    else if (p2 <= 0.75) tier2 = 'Top 75% opponent';
    if (gs.won) {
      if (trueAway2 && bigWin2)      reason2 = 'Win on the road by >13 vs ' + tier2;
      else if (!trueAway2 && bigWin2) reason2 = 'Win at home by >13 vs ' + tier2;
      else if (trueAway2)            reason2 = 'Win on the road by ≤13 vs ' + tier2;
      else                           reason2 = 'Win at home by ≤13 vs ' + tier2;
    } else {
      if (trueAway2 && closeLoss2)       reason2 = 'Loss on the road by <8 vs ' + tier2;
      else if (!trueAway2 && closeLoss2) reason2 = 'Loss at home by <8 vs ' + tier2;
      else if (trueAway2)                reason2 = 'Loss on the road by ≥8 vs ' + tier2;
      else                               reason2 = 'Loss at home by ≥8 vs ' + tier2;
    }
  }
  entry.reasonSoR = reason2;
})();

__calcData[team].games.push(entry);

    });
  });
%>
<script>
  window.__TEAM_CALC_DATA = <%- JSON.stringify(__calcData, null, 2) %>;
</script>


<%
  // Build meta array from rankings for safe JSON export (add champ bonus)
  const __metaArr = (rankings || []).map(r => ({
    team: r.teamName,
    sorTotal: Number(r.wlqTotal || 0),
    sorDenom: Number(r.sorDenomDebug || 0),
    psorDenom: Number((r.pSorDenomDebug != null ? r.pSorDenomDebug : r.sorDenomDebug) || 0),
    pfBonus: Number(r.appliedPfBonus || 0),
    paBonus: Number(r.appliedPaBonus || 0),
    smBonus: Number(r.appliedSmBonus || 0),
    champBonus: Number(r.appliedChampBonus || 0),
    totalBonus: Number((r.appliedPfBonus||0) + (r.appliedPaBonus||0) + (r.appliedSmBonus||0) + (r.appliedChampBonus||0)),
    powerSorAvg: Number(r.powerSorAvg || 0),
    sorAvg: Number(r.wlqAvg || 0),
    wonChampionship: !!r.wonChampionship,
    lostChampionship: !!r.lostChampionship
  }));
%>
<script>
  window.__TEAM_CALC_META = <%- JSON.stringify(__metaArr, null, 2) %>;
</script>


<hr />

<% fbsTeams.forEach(team => { 
    const stats = teamStats[team];
    let wins = 0, losses = 0;
    let runningWlqTotal = 0;
    let runningQualityTotal = 0;

    // scoring totals
    let teamPointsTotal = 0;
    let oppPointsTotal = 0;
    let gamesCount = 0;
%>
  <%
    // SoS tracking for this team
    let runningSoS = 0;
    // Future SoS = sum of opponent quality totals for incomplete games for this team
    let futureSoS = 0;
    (games || []).forEach(gm => {
      const isTeamGame = (gm.homeTeam === team || gm.awayTeam === team);
      if (isTeamGame && !gm.completed) {
        const opponentNameFS = gm.homeTeam === team ? gm.awayTeam : gm.homeTeam;
        const oppStatsFS = teamStats[opponentNameFS];
        futureSoS += oppStatsFS ? oppStatsFS.qualityTotal : 0;
      }
    });
    %>
    <h3 id="team-<%= team.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') %>" class="team-schedule-title">
  <% if (teamLogos && teamLogos[team]) { %>
    <img class="team-logo--header" src="<%= teamLogos[team] %>" alt="<%= team %> logo" />
  <% } %>
  <%= team %> Schedule
  (Record: <%= recordToString(stats.wins + (stats.wonChampionship?1:0), stats.losses + (stats.lostChampionship?1:0)) %><%= stats.wonChampionship ? '*' : '' %>)
  <span class="text-muted" style="font-weight: normal;">
    &nbsp;Conf:[
      <%= (conferenceRecords[team]?.confWins || 0) %>-
      <%= (conferenceRecords[team]?.confLosses || 0) %>
    ]
  </span>
</h3>

  <table border="1" cellspacing="0" cellpadding="5">
    <thead>
      <tr>
        <th>Week</th>
        <th>Home</th>
        <th>Away</th>
        <th><%= team %> Score</th>
        <th>Opp Score</th>
        <th>Result</th>
        <th>W/L</th>
        <th>QS</th>
        <th class="sor-col">SoR</th>
        <th>SoS</th>
        <th>PF/PA(SM)</th>
      </tr>
    </thead>
    <tbody>
      <% stats.gameStats.forEach(({game, won, qualityChange, wlqScore, isChampionship}) => {
          // running record includes champs with W/L shown inline
          if (!isChampionship) {
            if (won) wins++; else losses++;
            runningWlqTotal += wlqScore;
            runningQualityTotal += qualityChange;
          }
          const runningRecord = recordToString(wins, losses);

          const homeIsTeam = game.homeTeam === team;
          const awayIsTeam = game.awayTeam === team;

          const homeOppStats = teamStats[game.homeTeam] || { wins: 0, losses: 0, qualityTotal: 0 };
          const awayOppStats = teamStats[game.awayTeam] || { wins: 0, losses: 0, qualityTotal: 0 };

          // scoring totals (exclude champ from averages used elsewhere, but display raw here)
          let teamPoints = homeIsTeam ? Number(game.homePoints || 0) : Number(game.awayPoints || 0);
          let oppPoints  = homeIsTeam ? Number(game.awayPoints || 0) : Number(game.homePoints || 0);
          teamPointsTotal += teamPoints;
          oppPointsTotal += oppPoints;
          gamesCount++;

          const teamAvg = teamPointsTotal / gamesCount;
          const oppAvg  = oppPointsTotal / gamesCount;
          const margin  = teamAvg - oppAvg;
      %>
        <tr>
          <td><%= game.week %><% if (isChampionship) { %> (Champ)<% } %></td>

          <!-- Home Team -->
          <td>
            <%= game.homeTeam %>
            <% if (!homeIsTeam) { %>
              <% if (game.homeClassification === 'fbs') { %>
                [<%= recordToString(homeOppStats.wins, homeOppStats.losses) %>] 
                (<%= homeOppStats.qualityTotal.toFixed(2) %>)
              <% } else { %> (N/A) <% } %>
            <% } %>
          </td>

          <!-- Away Team -->
          <td>
            <%= game.awayTeam %>
            <% if (!awayIsTeam) { %>
              <% if (game.awayClassification === 'fbs') { %>
                [<%= recordToString(awayOppStats.wins, awayOppStats.losses) %>] 
                (<%= awayOppStats.qualityTotal.toFixed(2) %>)
              <% } else { %> (N/A) <% } %>
            <% } %>
          </td>

          <td><%= teamPoints %></td>
          <td><%= oppPoints %></td>
          <td><%= won ? "win" : "loss" %></td>
          <td
  data-bs-toggle="tooltip"
  data-bs-placement="top"
  title="<%= (teamConference[team] || 'Conf') %> Record [<%= (conferenceRecords[team]?.confWins || 0) %>-<%= (conferenceRecords[team]?.confLosses || 0) %>]">
  <%= runningRecord %>
</td>

          
<%
  // --- Tooltip reasons for QS and SoR (per-game) ---
  // Recompute context
  const _homeIsTeam = (game.homeTeam === team);
  const _trueAway   = (game.awayTeam === team) && (game.neutralSite === false);
  const _teamPts    = _homeIsTeam ? Number(game.homePoints || 0) : Number(game.awayPoints || 0);
  const _oppPts     = _homeIsTeam ? Number(game.awayPoints || 0) : Number(game.homePoints || 0);
  const _margin     = _teamPts - _oppPts;
  const _bigWin     = (_margin > 13);
  const _closeLoss  = (_margin < 0) && ((-_margin) < 8);
  const _oppName    = homeIsTeam ? game.awayTeam : game.homeTeam;
  const _oppClass   = (homeIsTeam ? (game.awayClassification || 'fbs') : (game.homeClassification || 'fbs'));
  const _oppConf    = (homeIsTeam ? (game.awayConference || '') : (game.homeConference || ''));
  const _oppInPower = isPowerConf(_oppConf, _oppName);
  const _oppNegQS   = !!(teamStats[_oppName] && Number(teamStats[_oppName].qualityTotal||0) < 0);

  // QS reason
  let qsReason = '';
  if (_oppClass === 'fcs') {
    qsReason = won ? 'Win vs FCS' : 'Loss vs FCS';
  } else if (_oppInPower) {
    if (won) {
      if (_oppNegQS) qsReason = 'Win vs Power opponent with negative QS';
      else if (_trueAway && _bigWin) qsReason = 'Win on the road by >13 vs Power opponent';
      else if (!_trueAway && _bigWin) qsReason = 'Win at home by >13 vs Power opponent';
      else if (_trueAway) qsReason = 'Win on the road by ≤13 vs Power opponent';
      else qsReason = 'Win at home by ≤13 vs Power opponent';
    } else {
      if (_oppNegQS) qsReason = 'Loss vs Power opponent with negative QS';
      else if (_trueAway && _closeLoss) qsReason = 'Loss on the road by <8 vs Power opponent';
      else if (!_trueAway && _closeLoss) qsReason = 'Loss at home by <8 vs Power opponent';
      else if (_trueAway) qsReason = 'Loss on the road by ≥8 vs Power opponent';
      else qsReason = 'Loss at home by ≥8 vs Power opponent';
    }
  } else { // non-power FBS
    if (won) {
      if (_oppNegQS) qsReason = 'Win vs FBS opponent with negative QS';
      else if (_trueAway && _bigWin) qsReason = 'Win on the road by >13 vs FBS opponent';
      else if (!_trueAway && _bigWin) qsReason = 'Win at home by >13 vs FBS opponent';
      else if (_trueAway) qsReason = 'Win on the road by ≤13 vs FBS opponent';
      else qsReason = 'Win at home by ≤13 vs FBS opponent';
    } else {
      if (_oppNegQS) qsReason = 'Loss vs FBS opponent with negative QS';
      else if (_trueAway && _closeLoss) qsReason = 'Loss on the road by <8 vs FBS opponent';
      else if (!_trueAway && _closeLoss) qsReason = 'Loss at home by <8 vs FBS opponent';
      else if (_trueAway) qsReason = 'Loss on the road by ≥8 vs FBS opponent';
      else qsReason = 'Loss at home by ≥8 vs FBS opponent';
    }
  }

  // SoR reason (tier-based). Use previously defined helpers for percentile on opponent QS.
  let sorReason = '';
  if (_oppClass === 'fcs') {
    sorReason = won ? 'Win vs FCS' : 'Loss vs FCS';
  } else {
    const _oppQS = Number((teamStats[_oppName] && teamStats[_oppName].qualityTotal) || 0);
    let _p = (typeof __percentileRankDesc_forTiers === 'function') ? __percentileRankDesc_forTiers(_oppQS) : 1;
    let tier = 'Bottom 25% opponent';
    if (_p <= 0.10) tier = 'Top 10% opponent';
    else if (_p <= 0.35) tier = 'Top 35% opponent';
    else if (_p <= 0.55) tier = 'Top 55% opponent';
    else if (_p <= 0.75) tier = 'Top 75% opponent';

    let loc = _trueAway ? 'on the road' : 'at home or neutral';
    sorReason = (won ? 'Win ' : 'Loss ') + loc + ' vs ' + tier;
  }
%>

<%
  // Build per-game QS & SoR tooltip reasons (table cells)
  const _homeIsTeam_tb = (game.homeTeam === team);
  const _trueAway_tb   = (game.awayTeam === team) && (game.neutralSite === false);
  const _tPts_tb       = _homeIsTeam_tb ? Number(game.homePoints || 0) : Number(game.awayPoints || 0);
  const _oPts_tb       = _homeIsTeam_tb ? Number(game.awayPoints || 0) : Number(game.homePoints || 0);
  const _marg_tb       = _tPts_tb - _oPts_tb;
  const _bigWin_tb     = (_marg_tb > 13);
  const _closeLoss_tb  = (_marg_tb < 0) && ((-_marg_tb) < 8);
  const _oppName_tb    = _homeIsTeam_tb ? game.awayTeam : game.homeTeam;
  const _oppClass_tb   = _homeIsTeam_tb ? (game.awayClassification || 'fbs') : (game.homeClassification || 'fbs');
  const _oppConf_tb    = _homeIsTeam_tb ? (game.awayConference || '') : (game.homeConference || '');
  const _oppInPower_tb = isPowerConf(_oppConf_tb, _oppName_tb);
  const _oppNegQS_tb   = !!(teamStats[_oppName_tb] && Number(teamStats[_oppName_tb].qualityTotal || 0) < 0);

  let qsReason_tb = '';
  if (_oppClass_tb === 'fcs') {
    qsReason_tb = won ? 'Win vs FCS' : 'Loss vs FCS';
  } else if (_oppInPower_tb) {
    if (won) {
      if (_oppNegQS_tb) qsReason_tb = 'Win vs Power opponent with negative QS';
      else if (_trueAway_tb && _bigWin_tb) qsReason_tb = 'Win on the road by >13 vs Power opponent';
      else if (!_trueAway_tb && _bigWin_tb) qsReason_tb = 'Win at home by >13 vs Power opponent';
      else if (_trueAway_tb) qsReason_tb = 'Win on the road by ≤13 vs Power opponent';
      else qsReason_tb = 'Win at home by ≤13 vs Power opponent';
    } else {
      if (_oppNegQS_tb) qsReason_tb = 'Loss vs Power opponent with negative QS';
      else if (_trueAway_tb && _closeLoss_tb) qsReason_tb = 'Loss on the road by <8 vs Power opponent';
      else if (!_trueAway_tb && _closeLoss_tb) qsReason_tb = 'Loss at home by <8 vs Power opponent';
      else if (_trueAway_tb) qsReason_tb = 'Loss on the road by ≥8 vs Power opponent';
      else qsReason_tb = 'Loss at home by ≥8 vs Power opponent';
    }
  } else {
    if (won) {
      if (_oppNegQS_tb) qsReason_tb = 'Win vs FBS opponent with negative QS';
      else if (_trueAway_tb && _bigWin_tb) qsReason_tb = 'Win on the road by >13 vs FBS opponent';
      else if (!_trueAway_tb && _bigWin_tb) qsReason_tb = 'Win at home by >13 vs FBS opponent';
      else if (_trueAway_tb) qsReason_tb = 'Win on the road by ≤13 vs FBS opponent';
      else qsReason_tb = 'Win at home by ≤13 vs FBS opponent';
    } else {
      if (_oppNegQS_tb) qsReason_tb = 'Loss vs FBS opponent with negative QS';
      else if (_trueAway_tb && _closeLoss_tb) qsReason_tb = 'Loss on the road by <8 vs FBS opponent';
      else if (!_trueAway_tb && _closeLoss_tb) qsReason_tb = 'Loss at home by <8 vs FBS opponent';
      else if (_trueAway_tb) qsReason_tb = 'Loss on the road by ≥8 vs FBS opponent';
      else qsReason_tb = 'Loss at home by ≥8 vs FBS opponent';
    }
  }

  let sorReason_tb = '';
  if (_oppClass_tb === 'fcs') {
    sorReason_tb = won ? 'Win vs FCS' : 'Loss vs FCS';
  } else {
    const _oppQSVal_tb = Number((teamStats[_oppName_tb] && teamStats[_oppName_tb].qualityTotal) || 0);
    let _p_tb = (typeof __percentileRankDesc_forTiers === 'function') ? __percentileRankDesc_forTiers(_oppQSVal_tb) : 1;
    let tier_tb = 'Bottom 25% opponent';
    if      (_p_tb <= 0.10) tier_tb = 'Top 10% opponent';
    else if (_p_tb <= 0.35) tier_tb = 'Top 35% opponent';
    else if (_p_tb <= 0.55) tier_tb = 'Top 55% opponent';
    else if (_p_tb <= 0.75) tier_tb = 'Top 75% opponent';

    if (won) {
      if (_trueAway_tb && _bigWin_tb)       sorReason_tb = 'Win on the road by >13 vs ' + tier_tb;
      else if (!_trueAway_tb && _bigWin_tb) sorReason_tb = 'Win at home by >13 vs ' + tier_tb;
      else if (_trueAway_tb)             sorReason_tb = 'Win on the road by ≤13 vs ' + tier_tb;
      else                            sorReason_tb = 'Win at home by ≤13 vs ' + tier_tb;
    } else {
      if (_trueAway_tb && _closeLoss_tb)       sorReason_tb = 'Loss on the road by <8 vs ' + tier_tb;
      else if (!_trueAway_tb && _closeLoss_tb) sorReason_tb = 'Loss at home by <8 vs ' + tier_tb;
      else if (_trueAway_tb)                sorReason_tb = 'Loss on the road by ≥8 vs ' + tier_tb;
      else                               sorReason_tb = 'Loss at home by ≥8 vs ' + tier_tb;
    }
  }
%>
<td>
  <%= runningQualityTotal.toFixed(2) %>
  (<span data-bs-toggle="tooltip" data-bs-placement="top" title="<%= qsReason_tb %>"><%= (!isChampionship ? qualityChange.toFixed(2) : '0.00') %></span>)
</td>
<td>
  <%= runningWlqTotal.toFixed(2) %>
  (<span data-bs-toggle="tooltip" data-bs-placement="top" title="<%= sorReason_tb %>"><%= (!isChampionship ? wlqScore.toFixed(2) : '0.00') %></span>)
</td>


          
        <% 
          const opponentName = homeIsTeam ? game.awayTeam : game.homeTeam;
          const oppQualityNow = (teamStats[opponentName] ? teamStats[opponentName].qualityTotal : 0);
          runningSoS += Number(oppQualityNow) || 0;
        %>
        <td><%= runningSoS.toFixed(2) %></td>
        <td>
          <% if (gamesCount <= 2) { %>
            <%= (teamPointsTotal / gamesCount).toFixed(0) %>-
            <%= (oppPointsTotal / gamesCount).toFixed(0) %>
            (<%= margin.toFixed(0) %>)
          <% } else { %>
            <%= teamAvg.toFixed(1) %>-
            <%= oppAvg.toFixed(1) %>
            (<%= margin.toFixed(1) %>)
          <% } %>
        </td>
        </tr>
      <% }) %>
      <% if (futureSoS > 0) { %>
        <tr>
          <td colspan="9"></td>
          <td>Future SoS (<%= futureSoS.toFixed(2) %>)</td>
          <td></td>
        </tr>
      <% } %>

    </tbody>
  </table>
  <hr />
<% }) %>

        </div>
      </div>
    </div>
  </div>

  <div class="footer d-flex justify-content-center align-items-center">
    <h5>&copy; Taylor Bros. Gaming - 2025</h5>
  </div>

  <style>
    /* rankings table sorting helpers */
    #rankingsTable th { cursor: pointer; user-select: none; position: relative; }
    #rankingsTable th .sort-arrow { font-size: 0.8em; margin-left: .35rem; opacity: .4; }
    #rankingsTable th.active .sort-arrow { opacity: 1; }
  </style>

 
  <script>
document.addEventListener("DOMContentLoaded", () => {
  // === Local time header ===
  try {
    const d = new Date();
    const options = { year:'numeric', month:'2-digit', day:'2-digit', hour:'numeric', minute:'2-digit', hour12:true, timeZoneName:'short' };
    const header = document.getElementById("asOfHeader");
    if (header) header.textContent = "Rankings as of " + d.toLocaleString(undefined, options);
  } catch (e) { console.warn("Time header error:", e); }

  // === Rankings table sorting ===
  try {
    const table = document.getElementById("rankingsTable");
    if (table) {
      const headers = Array.from(table.querySelectorAll("thead th"));
      headers.forEach(th => {
        const span = document.createElement("span");
        span.className = "sort-arrow";
        span.textContent = "⇅";
        th.appendChild(span);
      });

      const numericFromText = (t) => {
        const m = t.replace(/,/g, '').match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : NaN;
      };
      const recordToPct = (t) => {
        const m = t.match(/(\d+)\s*-\s*(\d+)/);
        if (!m) return NaN;
        const w = parseInt(m[1],10), l = parseInt(m[2],10);
        return (w+l)>0 ? w/(w+l) : 0;
      };
      const typeOf = (txt) => {
        const t = txt.trim().toLowerCase();
        if (t === 'rank') return 'int';
        if (t === 'team') return 'text';
        if (t === 'w/l') return 'record';
        return 'num';
      };
      const setArrow = (th, asc) => {
        headers.forEach(h => {
          h.classList.remove('active');
          const s=h.querySelector('.sort-arrow'); 
          if (s) s.textContent='⇅';
        });
        const s = th.querySelector('.sort-arrow');
        if (s) { th.classList.add('active'); s.textContent = asc ? '▲' : '▼'; }
      };

      headers.forEach((th, idx) => {
        th.addEventListener('click', () => {
          const tbody = table.tBodies[0];
          const rows = Array.from(tbody.querySelectorAll('tr'));
          const asc = !(th._asc === true); th._asc = asc;
          const kind = typeOf(th.childNodes[0].textContent || th.textContent);
          rows.sort((A,B) => {
            const aT=(A.cells[idx]?.innerText||'').trim();
            const bT=(B.cells[idx]?.innerText||'').trim();
            let aV,bV;
            if (kind==='int'){ aV=parseInt(aT,10); bV=parseInt(bT,10); }
            else if (kind==='record'){ aV=recordToPct(aT); bV=recordToPct(bT); }
            else if (kind==='num'){ aV=numericFromText(aT); bV=numericFromText(bT); }
            else { aV=aT.toLowerCase(); bV=bT.toLowerCase(); }
            const aNaN = (typeof aV==='number' && isNaN(aV));
            const bNaN = (typeof bV==='number' && isNaN(bV));
            if (aNaN && bNaN) return 0; if (aNaN) return 1; if (bNaN) return -1;
            if (aV < bV) return asc ? -1 : 1;
            if (aV > bV) return asc ? 1 : -1;
            return 0;
          });
          rows.forEach(r => tbody.appendChild(r));
          setArrow(th, asc);
        });
      });
    }
  } catch (e) { console.warn("Sorting init error:", e); }

  // === Header tooltips (Rankings + Team tables) ===
  try {
    const headerLongNames = {
      "Rank": "Ranking",
      "Team": "Team",
      "W/L": "Wins–Losses",
      "SoR": "Strength of Record",
      "SoR Avg": "Strength of Record Average",
      "PF": "Scoring Average",
      "PA": "Points Allowed Average",
      "SM": "Scoring Margin",
      "PF/PA(SM)": "Scoring Avg, Points Allowed Avg, (Scoring Margin)",
      "SoS": "Strength of Schedule",
      "PSoR": "Power Strength of Record",
      "Week": "Week of Season",
      "Home": "Home Team",
      "Away": "Away Team",
      "Score": "Points Scored",
      "Opp Score": "Opponent Points Scored",
      "Result": "Win or Loss",
      "Record": "Overall Record",
      "QS": "Cumulative Quality Score (Change from this game)",
      "SoR": "Strength of Record Total (Change from this game)"
    };
    const allThs = document.querySelectorAll("table thead th");
    allThs.forEach(th => {
      const label = (th.childNodes[0]?.textContent || th.textContent || "").trim();
      const longName = headerLongNames[label];
      if (longName) {
        th.setAttribute("data-bs-toggle", "tooltip");
        th.setAttribute("data-bs-placement", "top");
        th.setAttribute("title", longName);
        th.setAttribute("aria-label", longName);
      }
    });
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => { new bootstrap.Tooltip(el, { container: 'body' }); });
  } catch (e) { console.warn("Tooltip init error:", e); }

  // === Mobile navbar links -> modal open ===
  const navCollapseEl = document.getElementById("navbarExample01"); // collapse container id
  const infoModalEl   = document.getElementById("infoModal");
  const infoTitleEl   = document.getElementById("infoModalTitle");
  const infoBodyEl    = document.getElementById("infoModalBody");

  const getNavCollapse = () => {
    if (!navCollapseEl) return null;
    let inst = bootstrap.Collapse.getInstance(navCollapseEl);
    if (!inst) inst = new bootstrap.Collapse(navCollapseEl, { toggle: false });
    return inst;
  };
  const getModal = () => {
    if (!infoModalEl) return null;
    let inst = bootstrap.Modal.getInstance(infoModalEl);
    if (!inst) inst = new bootstrap.Modal(infoModalEl, { backdrop: true, keyboard: true });
    return inst;
  };

  // Close modal when clicking inside modal content (in addition to backdrop + X)
  if (infoModalEl) {
    infoModalEl.addEventListener('shown.bs.modal', () => {
      const content = document.getElementById('infoModalContent');
      const onClickToClose = (e) => {
        if (content.contains(e.target)) {
          const modal = getModal();
          if (modal) modal.hide();
        }
      };
      content.addEventListener('click', onClickToClose, { once: true });
    });
  }

  function openInfo(which) {
    const isAbout = which === 'about';
    const srcCard = document.querySelector(isAbout ? '#aboutCollapse .card' : '#glossaryCollapse .card');
    if (!srcCard) { console.warn("Source content not found for", which); return; }

    if (infoTitleEl) infoTitleEl.textContent = isAbout ? 'About This Ranking System' : 'Glossary';
    if (infoBodyEl) infoBodyEl.innerHTML = srcCard.innerHTML;

    const modal = getModal();
    if (modal) modal.show();
    else console.warn("Modal instance not available");
  }

  const mobileLinks = document.querySelectorAll('.js-open-info[data-info]');
  mobileLinks.forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const which = link.getAttribute('data-info');
      if (!which) return;

      if (window.innerWidth < 992) { // mobile
        const nav = getNavCollapse();
        if (nav && navCollapseEl && navCollapseEl.classList.contains('show')) {
          const onHidden = () => {
            navCollapseEl.removeEventListener('hidden.bs.collapse', onHidden);
            openInfo(which);
          };
          navCollapseEl.addEventListener('hidden.bs.collapse', onHidden);
          nav.hide();
        } else {
          openInfo(which);
        }
      } else {
        // Desktop: toggle in-page collapsibles
        const targetId = which === 'about' ? '#aboutCollapse' : '#glossaryCollapse';
        const target = document.querySelector(targetId);
        if (target) {
          let inst = bootstrap.Collapse.getInstance(target);
          if (!inst) inst = new bootstrap.Collapse(target, { toggle: false });
          inst.toggle();
          const navH = (document.querySelector('.navbar.fixed-top')?.offsetHeight || 0) + 8;
          const top = target.getBoundingClientRect().top + window.pageYOffset - navH;
          window.scrollTo({ top, behavior: 'smooth' });
        }
      }
    });
  });
});
</script>


<!-- Generic Info Modal -->
<div class="modal fade" id="infoModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content" id="infoModalContent">
      <div class="modal-header">
        <h5 class="modal-title" id="infoModalTitle">Info</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="infoModalBody">
        <!-- injected dynamically -->
      </div>
    </div>
  </div>
</div>

<!-- Back to top -->
<button id="backToTopBtn" class="btn btn-primary rounded-circle" style="position:fixed;bottom:20px;right:20px;z-index:1050;width:48px;height:48px;box-shadow:0 4px 12px rgba(0,0,0,.2);" aria-label="Back to top">↑</button>

<!-- Calculation Detail Modal -->
<div class="modal fade" id="calcModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="calcModalTitle">Calculation</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="calcModalBody"></div>
    </div>
  </div>
</div>


<script>
(function(){
  function fmt(x, d){ return (Number(x)||0).toFixed(d); }
  function getMeta(team){
    const arr = window.__TEAM_CALC_META || [];
    for (let i=0; i<arr.length; i++){
      if (arr[i].team === team) return arr[i];
    }
    return null;
  }
  function buildGameRows(team){
    const bundle = (window.__TEAM_CALC_DATA && window.__TEAM_CALC_DATA[team]) || { games: [] };
    const games = (bundle.games || []).slice().sort((a,b)=>a.week-b.week);
    if (!games.length) return "<p>No completed games yet.</p>";
    let cum = 0;
    let html = '<div class="table-responsive"><table class="table table-sm table-striped align-middle">';
    html += '<thead><tr><th>Week</th><th>Opponent</th><th>Opp QS</th><th>SoR from Game (WLQ)</th><th>Result</th></tr></thead><tbody>';
    games.forEach(g => {
      cum += (Number(g.wlq)||0);
      html += '<tr>'
        + '<td>'+g.week+'</td>'
        + '<td>'+g.opponent+'</td>'
        + '<td>'+fmt(g.opponentQS,3)+'</td>'
        + '<td><span data-bs-toggle="tooltip" data-bs-placement="top" title="'+(g.reasonSoR||'')+'">'+fmt(g.wlq,3)+'</span></td>'
        + '<td>'+g.result+'</td>'
        + '</tr>';
    });
    html += '</tbody></table></div>';
    html += '<p class="mb-1"><strong>Cumulative SoR (Σ WLQ):</strong> '+fmt(cum,3)+'</p>';
    return html;
  }
  function buildSoRSection(team){
    const m = getMeta(team) || {};
    const gamesHtml = buildGameRows(team);
    const lines = `
      <h6 class="mb-2">SoR Average — Formula</h6>
      <div class="table-responsive mb-2">
        <table class="table table-bordered table-sm align-middle">
          <thead>
            <tr><th>Variable</th><th>Definition</th><th>Value</th></tr>
          </thead>
          <tbody>
            <tr><td>SoR Total</td><td>Σ WLQ (per-game strength-of-record)</td><td>${fmt(m.sorTotal,3)}</td></tr>
            <tr><td>SoR Avg</td><td>SoR Total ÷ Games Played</td><td><strong>${fmt(m.sorAvg,3)}</strong></td></tr>
          </tbody>
        </table>
      </div>
    `;
    return gamesHtml + lines;
  }
  function buildPSoRSection(team){
    const m = getMeta(team) || {};
    const bonusBreak = `PF: ${fmt(m.pfBonus,3)} | PA: ${fmt(m.paBonus,3)} | SM: ${fmt(m.smBonus,3)} | Championship: ${fmt(m.champBonus,3)} | Total: ${fmt(m.totalBonus,3)}`;
    const lines = `
      <h6 class="mb-2">Power SoR Average — Formula</h6>
      <div class="table-responsive mb-2">
        <table class="table table-bordered table-sm align-middle">
          <thead>
            <tr><th>Variable</th><th>Definition</th><th>Value</th></tr>
          </thead>
          <tbody>
            <tr><td>SoR Total</td><td>Σ WLQ</td><td>${fmt(m.sorTotal,3)}</td></tr>
            <tr><td>Bonuses (pre-avg)</td><td>PF (0.3×week/12) + PA (0.3×week/12) + SM (0.8×week/12) + <strong>Championship (+0.30 win / -0.10 loss)</strong></td><td>${bonusBreak}</td></tr>
            <tr><td>PSoR Avg</td><td>(SoR Total + Bonuses) ÷ Games Played</td><td><strong>${fmt(m.powerSorAvg,3)}</strong></td></tr>
          </tbody>
        </table>
      </div>
    `;
    return lines;
  }
  function openCalcModal(kind, team){
    const modalEl = document.getElementById('calcModal');
    const titleEl = document.getElementById('calcModalTitle');
    const bodyEl  = document.getElementById('calcModalBody');
    if (!modalEl || !titleEl || !bodyEl) return;
    titleEl.textContent = (kind === 'psor' ? 'PSoR Avg — ' : 'SoR Avg — ') + team;
    let html = '';
    if (kind === 'psor') html = buildSoRSection(team) + buildPSoRSection(team);
    else html = buildSoRSection(team);
    bodyEl.innerHTML = html;
    try {
      const tts = [].slice.call(document.querySelectorAll('#calcModal [data-bs-toggle=\"tooltip\"]'));
      tts.forEach(el => { new bootstrap.Tooltip(el, { container: '#calcModal' }); });
    } catch(e) { console.warn('Modal tooltip init error', e); }
    let inst = bootstrap.Modal.getInstance(modalEl);
    if (!inst) inst = new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true });
    inst.show();
  }
  document.addEventListener('DOMContentLoaded', function(){
    document.querySelectorAll('.js-open-calc[data-team]').forEach(btn => {
      btn.addEventListener('click', () => {
        const team = btn.getAttribute('data-team');
        const kind = btn.getAttribute('data-kind'); // "sor" or "psor"
        if (!team || !kind) return;
        openCalcModal(kind, team);
      });
    });
    const backBtn = document.getElementById('backToTopBtn');
    if (backBtn) backBtn.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));
  });
})();
</script>


<style>
  /* Ensure anchored headers land below the fixed navbar by ~100px */
  .team-schedule-title { scroll-margin-top: calc(var(--nav-offset, 0px) + 100px); }
</style>
<script>
document.addEventListener('DOMContentLoaded', function(){
  function setNavOffset(){
    var nav = document.querySelector('.navbar.fixed-top');
    var h = (nav && nav.offsetHeight) ? nav.offsetHeight : 0;
    document.documentElement.style.setProperty('--nav-offset', h + 'px');
  }
  setNavOffset();
  window.addEventListener('resize', setNavOffset);

  document.body.addEventListener('click', function(e){
    var a = e.target.closest('a.js-team-link[href^="#team-"]');
    if (!a) return;
    var id = (a.getAttribute('href') || '').slice(1);
    if (!id) return;
    e.preventDefault();
    var el = document.getElementById(id);
    if (el && el.scrollIntoView) {
      el.scrollIntoView({ behavior: 'smooth', block: 'start' });
      history.replaceState(null, '', '#' + id);
    }
  });

  if (location.hash && location.hash.startsWith('#team-')) {
    var el = document.getElementById(location.hash.slice(1));
    if (el && el.scrollIntoView) {
      // use a tiny delay to allow layout stabilize
      setTimeout(function(){ el.scrollIntoView({ behavior: 'instant', block: 'start' }); }, 0);
    }
  }
});
</script>

</body>
</html>
